# unimechanic theory

### Разберем пошагово как выполняется данный код:

```javascript
const arr = [10, 12, 15, 21];

for (var i = 0; i < arr.length; i++) {
  setTimeout(function () {
    console.log(arr[i] > 13 ? `Good ${arr[i]}` : `Bad ${arr[i]}`);
  }, 3000);
}
```

1. Объяляется массив arr.
2. Запускается цикл for.
3. На каждой итерации цикла вызывается функция setTimeout. Эта функция откладывает выполнение переданной ей функции обратного вызова на 3 секунды;
4. Функция обратного вызова setTimeout выводит в консоль сообщение в зависимости от условия: если элемент массива arr[i] больше 13, то выведется сообщение "Good: <значение>", иначе "Bad: <значение>".
5. Проблема возникает из-за асинхронной природы setTimeout. Функция обратного вызова запустится через 3 секунды, переменная i уже будет равна arr.length, так как цикл уже закончился. Поэтому arr[i] будет undefined.
6. Когда функция обратного вызова пытается обратиться к arr[i], i будет равно arr.length, что приведет к ошибке TypeError, потому что arr[arr.length] (или arr[4] в данном случае) равно undefined.
7. Через 3 секунды каждое из сообщений выводится в консоль, но в случае arr[i] будет выведено undefined.

### Для того чтобы избежать этой ошибки необходимо модифицировать код:

```javascript
const arr = [10, 12, 15, 21];

for (var i = 0; i < arr.length; i++) {
  setTimeout(
    function (num) {
      console.log(num > 13 ? `Good ${num}` : `Bad ${num}`);
    },
    3000,
    arr[i]
  );
}
```

Третий аргумент функции setTimeout определяет аргумент, который будет передан функции обратного вызова после завершения указанного временного интервала.

Так как у нас нет необходимости в настройке счетчика цикла for, мы можем модифицировать код с использованием синтаксиса ES6:

```javascript
const arr = [10, 12, 15, 21];

for (value of arr) {
  setTimeout(
    function (num) {
      console.log(num > 13 ? `Good ${num}` : `Bad ${num}`);
    },
    3000,
    value
  );
}
```
